---
- name: Remediation for CIS 1.1.2.4.1 - Ensure separate partition exists for /var
  hosts: all
  become: yes
  gather_facts: false
  vars:
    checkpoint_id: "cis_1_1_2_4_1"
    state_guard_dir: "/tmp/.cis_state_guard/{{ checkpoint_id }}"
    state_guard_flag: "{{ state_guard_dir }}/checkpoint.flag"
    kcs_article: "CIS RHEL 9 Benchmark v2.0.0 checkpoint 1.1.2.4.1"
    
    # REQUIREMENT VARIABLES - CRITICAL: ALL req_ variables MUST be quoted strings
    req_0: "Check if /var is already on a separate partition"
    req_1: "Check if system is new or existing installation"
    req_2: "For new installations: During OS installation, create custom partition layout and specify separate partition for /var"
    req_3: "For existing installations: Create new partition using available disk space"
    req_4: "For existing installations: Create filesystem on new partition"
    req_5: "For existing installations: Create temporary mount point and copy /var data"
    req_6: "For existing installations: Update /etc/fstab to mount new partition at /var"
    req_7: "For existing installations: Reboot system or remount all filesystems"
    req_8: "Verify /var is on separate partition"

  pre_tasks:
    # === STATE GUARD: Ensure pristine state for each remediation attempt ===
    - name: "State Guard - Check for existing checkpoint"
      stat:
        path: "{{ state_guard_flag }}"
      register: _sg_flag

    # RESTORE PHASE: If checkpoint exists, previous run left dirty state - restore /etc/fstab
    - name: "State Guard - Restore /etc/fstab from backup"
      copy:
        src: "{{ state_guard_dir }}/fstab.bak"
        dest: "/etc/fstab"
        remote_src: true
      when: _sg_flag.stat.exists
      ignore_errors: true

    # RESTORE PHASE: Clean up partitions and filesystems from previous failed run
    - name: "State Guard - Clean up temporary mount point"
      file:
        path: "/mnt/var_new"
        state: absent
      when: _sg_flag.stat.exists
      ignore_errors: true

    - name: "State Guard - Remove partition info file"
      file:
        path: "/tmp/var_partition.info"
        state: absent
      when: _sg_flag.stat.exists
      ignore_errors: true

    - name: "State Guard - Remove old checkpoint"
      file:
        path: "{{ state_guard_dir }}"
        state: absent
      when: _sg_flag.stat.exists

    # CAPTURE PHASE: Backup current pristine state before remediation
    - name: "State Guard - Create checkpoint directory"
      file:
        path: "{{ state_guard_dir }}"
        state: directory
        mode: '0700'

    - name: "State Guard - Backup /etc/fstab"
      copy:
        src: "/etc/fstab"
        dest: "{{ state_guard_dir }}/fstab.bak"
        remote_src: true
      ignore_errors: true

    - name: "State Guard - Create checkpoint flag"
      copy:
        content: "checkpoint"
        dest: "{{ state_guard_flag }}"

  tasks:
    - name: Initialize data variables
      set_fact:
        data_0: ""
        data_1: ""
        data_2: ""
        data_3: ""
        data_4: ""
        data_5: ""
        data_6: ""
        data_7: ""
        data_8: ""
        task_0_name: "Not executed"
        task_0_cmd: "N/A"
        task_0_rc: -1
        task_1_name: "Not executed"
        task_1_cmd: "N/A"
        task_1_rc: -1
        task_2_name: "Not executed"
        task_2_cmd: "N/A"
        task_2_rc: -1
        task_3_name: "Not executed"
        task_3_cmd: "N/A"
        task_3_rc: -1
        task_4_name: "Not executed"
        task_4_cmd: "N/A"
        task_4_rc: -1
        task_5_name: "Not executed"
        task_5_cmd: "N/A"
        task_5_rc: -1
        task_6_name: "Not executed"
        task_6_cmd: "N/A"
        task_6_rc: -1
        task_7_name: "Not executed"
        task_7_cmd: "N/A"
        task_7_rc: -1
        task_8_name: "Not executed"
        task_8_cmd: "N/A"
        task_8_rc: -1

    # Requirement 0: Check if /var is already on a separate partition
    - name: "Req 0 - Check if /var is already on separate partition"
      shell: |
        findmnt --kernel /var
      args:
        executable: /bin/bash
      register: result_0
      ignore_errors: true
      changed_when: false

    - name: Store requirement 0 details
      set_fact:
        task_0_name: "Check if /var is already on separate partition"
        task_0_cmd: "findmnt --kernel /var"
        task_0_rc: "{{ result_0.rc | default(-1) }}"
        data_0: "{{ result_0.stdout | default('') | trim }}"
        status_0: >-
          {% set output = result_0.stdout | default('') | trim %}
          {% if output != '' and ' / ' not in output %}
            APPLIED
          {% else %}
            FAILED
          {% endif %}
        rationale_0: >-
          {% set output = result_0.stdout | default('') | trim %}
          {% if output != '' and ' / ' not in output %}
            APPLIED: /var is already on separate partition
          {% else %}
            FAILED: /var is not on separate partition, remediation needed
          {% endif %}

    # Set skipped status for Requirements 1-7 when already compliant
    - name: "Set skipped status for Requirements 1-7 when already compliant"
      set_fact:
        status_1: "SKIPPED"
        status_2: "SKIPPED"
        status_3: "SKIPPED"
        status_4: "SKIPPED"
        status_5: "SKIPPED"
        status_6: "SKIPPED"
        status_7: "SKIPPED"
        rationale_1: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_2: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_3: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_4: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_5: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_6: "SKIPPED: System already compliant, /var is on separate partition"
        rationale_7: "SKIPPED: System already compliant, /var is on separate partition"
      when: "status_0 | trim == 'APPLIED'"

    # Requirement 1: Check if system is new or existing installation
    # Since this cannot be determined accurately post-installation, we assume existing installation
    - name: "Req 1 - Determine installation type"
      shell: |
        echo "Cannot accurately determine if this is a new or existing installation post-installation."
        echo "Assuming existing installation for remediation purposes."
        echo "NEW_INSTALLATION=false"
      args:
        executable: /bin/bash
      register: result_1
      ignore_errors: true
      when: "status_0 | trim == 'FAILED'"

    - name: Store requirement 1 details and set installation type
      set_fact:
        task_1_name: "Determine installation type"
        task_1_cmd: "Assume existing installation for remediation"
        task_1_rc: "{{ result_1.rc | default(-1) }}"
        data_1: "{{ result_1.stdout | default('') | trim }}"
        status_1: "APPLIED"
        rationale_1: "APPLIED: Assuming existing installation for remediation since accurate determination post-installation is not possible"
        is_new_installation: "false"
      when: "status_0 | trim == 'FAILED'"

    # Requirement 2: For new installations - not applicable post-installation
    - name: "Req 2 - New installation guidance"
      shell: |
        echo "For new installations: During OS installation, create a custom partition setup"
        echo "and specify a separate partition for /var."
        echo ""
        echo "This requirement is not applicable post-installation."
        echo "The remediation procedure states: 'For new installations, during installation create a custom partition setup'"
      args:
        executable: /bin/bash
      register: result_2
      ignore_errors: true
      when: "status_0 | trim == 'FAILED'"

    - name: Store requirement 2 details for new installation
      set_fact:
        task_2_name: "New installation guidance"
        task_2_cmd: "echo guidance for new installation partitioning"
        task_2_rc: "{{ result_2.rc | default(-1) }}"
        data_2: "{{ result_2.stdout | default('') | trim }}"
        status_2: "SKIPPED"
        rationale_2: "SKIPPED: New installation partitioning cannot be applied post-installation"
      when: "status_0 | trim == 'FAILED'"

    # Requirement 3: For existing installations - Create new partition using available disk space
    - name: "Req 3 - Create new partition using available disk space"
      shell: |
        echo "=== AVAILABLE DISKS ==="
        lsblk
        
        echo "=== SELECTING AVAILABLE DISK ==="
        # Find first available disk without partitions or with free space
        AVAILABLE_DISK=""
        for disk in /dev/sd[a-z] /dev/vd[a-z] /dev/xvd[a-z]; do
          if [ -b "$disk" ]; then
            PARTITION_COUNT=$(lsblk -ln "$disk" | grep -c "^${disk##*/}[0-9]")
            if [ "$PARTITION_COUNT" -eq 0 ] || $(parted -s "$disk" print free | grep -q "Free Space"); then
              AVAILABLE_DISK="$disk"
              break
            fi
          fi
        done
        
        if [ -z "$AVAILABLE_DISK" ]; then
          echo "ERROR: No available disk found"
          exit 1
        fi
        
        echo "Using disk: $AVAILABLE_DISK"
        
        # Create partition using parted
        echo "=== CREATING PARTITION ==="
        if ! parted -s "$AVAILABLE_DISK" print 2>/dev/null | grep -q "Partition Table"; then
          parted -s "$AVAILABLE_DISK" mklabel gpt
        fi
        
        # Find free space and create partition
        FREE_START=$(parted -s "$AVAILABLE_DISK" unit MB print free | grep "Free Space" | head -1 | awk '{print $1}')
        FREE_END=$(parted -s "$AVAILABLE_DISK" unit MB print free | grep "Free Space" | head -1 | awk '{print $2}')
        
        if [ -z "$FREE_START" ] || [ -z "$FREE_END" ]; then
          # Use whole disk if no partitions
          parted -s "$AVAILABLE_DISK" mkpart primary ext4 1MB 100%
        else
          # Use free space
          parted -s "$AVAILABLE_DISK" mkpart primary ext4 "${FREE_START}MB" "${FREE_END}MB"
        fi
        
        # Determine partition name
        if [[ "$AVAILABLE_DISK" =~ /dev/sd[a-z]$ ]]; then
          NEW_PARTITION="${AVAILABLE_DISK}1"
        elif [[ "$AVAILABLE_DISK" =~ /dev/vd[a-z]$ ]]; then
          NEW_PARTITION="${AVAILABLE_DISK}1"
        elif [[ "$AVAILABLE_DISK" =~ /dev/xvd[a-z]$ ]]; then
          NEW_PARTITION="${AVAILABLE_DISK}1"
        else
          NEW_PARTITION="${AVAILABLE_DISK}p1"
        fi
        
        # Wait for partition to appear
        sleep 2
        partprobe "$AVAILABLE_DISK"
        
        echo "New partition created: $NEW_PARTITION"
        echo "NEW_PARTITION=$NEW_PARTITION" > /tmp/var_partition.info
        echo "AVAILABLE_DISK=$AVAILABLE_DISK" >> /tmp/var_partition.info
        lsblk "$NEW_PARTITION"
      args:
        executable: /bin/bash
      register: result_3
      ignore_errors: true
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED'"

    - name: Store requirement 3 details
      set_fact:
        task_3_name: "Create new partition using available disk space"
        task_3_cmd: "parted to create partition on available disk"
        task_3_rc: "{{ result_3.rc | default(-1) }}"
        data_3: "{{ result_3.stdout | default('') | trim }}"
        status_3: "{{ ('APPLIED' if result_3.rc | default(-1) == 0 else 'FAILED') | trim }}"
        rationale_3: "{{ ('APPLIED: New partition created' if result_3.rc | default(-1) == 0 else 'FAILED: Could not create partition') | trim }}"
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED'"

    # Requirement 4: Create filesystem on new partition
    - name: "Req 4 - Create filesystem on new partition"
      shell: |
        # Read partition info from previous step
        if [ -f /tmp/var_partition.info ]; then
          source /tmp/var_partition.info
          echo "Creating filesystem on $NEW_PARTITION"
          
          # Use xfs as specified in remediation procedure
          if command -v mkfs.xfs >/dev/null 2>&1; then
            mkfs.xfs -f "$NEW_PARTITION"
            FS_TYPE="xfs"
          else
            echo "WARNING: mkfs.xfs not found, using ext4 as fallback"
            mkfs.ext4 -F "$NEW_PARTITION"
            FS_TYPE="ext4"
          fi
          
          echo "Filesystem type: $FS_TYPE"
          echo "FS_TYPE=$FS_TYPE" >> /tmp/var_partition.info
          
          # Verify filesystem
          if [ "$FS_TYPE" = "xfs" ]; then
            xfs_admin -l "$NEW_PARTITION"
          else
            tune2fs -l "$NEW_PARTITION" | head -20
          fi
        else
          echo "ERROR: Partition information not found"
          exit 1
        fi
      args:
        executable: /bin/bash
      register: result_4
      ignore_errors: true
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED'"

    - name: Store requirement 4 details
      set_fact:
        task_4_name: "Create filesystem on new partition"
        task_4_cmd: "mkfs.xfs on new partition (ext4 fallback)"
        task_4_rc: "{{ result_4.rc | default(-1) }}"
        data_4: "{{ result_4.stdout | default('') | trim }}"
        status_4: "{{ ('APPLIED' if result_4.rc | default(-1) == 0 else 'FAILED') | trim }}"
        rationale_4: "{{ ('APPLIED: Filesystem created on new partition' if result_4.rc | default(-1) == 0 else 'FAILED: Could not create filesystem') | trim }}"
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED'"

    # Requirement 5: Create temporary mount point and copy /var data
    # FIXED: Use actual partition variable instead of literal /dev/[new-partition]
    - name: "Req 5 - Create temporary mount point and copy /var data"
      shell: |
        # Read partition and filesystem info
        source /tmp/var_partition.info
        
        echo "=== BEFORE COPY - CURRENT /VAR USAGE ==="
        df -h /var
        
        echo "=== CREATING TEMPORARY MOUNT ==="
        # Use exact command from remediation procedure with actual partition variable
        mkdir /mnt/var_new && mount "$NEW_PARTITION" /mnt/var_new && cp -arx /var/* /mnt/var_new/
        
        echo "=== VERIFYING COPY ==="
        du -sh /var /mnt/var_new
        ls -la /var | head -10
        ls -la /mnt/var_new | head -10
        
        echo "Data copy completed"
      args:
        executable: /bin/bash
      register: result_5
      ignore_errors: true
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED'"

    - name: Store requirement 5 details
      set_fact:
        task_5_name: "Create temporary mount point and copy /var data"
        task_5_cmd: "mkdir /mnt/var_new && mount $NEW_PARTITION /mnt/var_new && cp -arx /var/* /mnt/var_new/"
        task_5_rc: "{{ result_5.rc | default(-1) }}"
        data_5: "{{ result_5.stdout | default('') | trim }}"
        status_5: "{{ ('APPLIED' if result_5.rc | default(-1) == 0 else 'FAILED') | trim }}"
        rationale_5: "{{ ('APPLIED: /var data copied to new partition using exact procedure command' if result_5.rc | default(-1) == 0 else 'FAILED: Could not copy /var data') | trim }}"
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED'"

    # Requirement 6: Update /etc/fstab to mount new partition at /var
    - name: "Req 6 - Update /etc/fstab to mount new partition at /var"
      shell: |
        # Read partition and filesystem info
        source /tmp/var_partition.info
        
        echo "=== BEFORE ==="
        cat /etc/fstab
        echo "=== APPLYING CHANGE ==="
        
        # Use exact command from remediation procedure with actual partition variable
        # First remove any existing /var entry to avoid duplicates
        grep -v "[[:space:]]/var[[:space:]]" /etc/fstab > /etc/fstab.tmp
        mv /etc/fstab.tmp /etc/fstab
        
        # Now append the new entry using exact format from procedure with actual partition
        echo "$NEW_PARTITION /var xfs defaults 0 0" >> /etc/fstab
        
        echo "=== AFTER ==="
        cat /etc/fstab
      args:
        executable: /bin/bash
      register: result_6
      ignore_errors: true
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED' and status_5 | trim == 'APPLIED'"

    - name: Store requirement 6 details
      set_fact:
        task_6_name: "Update /etc/fstab to mount new partition at /var"
        task_6_cmd: "echo '$NEW_PARTITION /var xfs defaults 0 0' >> /etc/fstab"
        task_6_rc: "{{ result_6.rc | default(-1) }}"
        data_6: "{{ result_6.stdout | default('') | trim }}"
        status_6: "{{ ('APPLIED' if result_6.rc | default(-1) == 0 else 'FAILED') | trim }}"
        rationale_6: "{{ ('APPLIED: /etc/fstab updated with new /var partition using exact procedure command' if result_6.rc | default(-1) == 0 else 'FAILED: Could not update /etc/fstab') | trim }}"
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED' and status_5 | trim == 'APPLIED'"

    # Requirement 7: Reboot system or remount all filesystems
    - name: "Req 7 - Reboot system or remount all filesystems"
      shell: |
        echo "=== REMOUNTING FILESYSTEMS ==="
        # Use mount -a as specified in remediation procedure
        mount -a
        
        echo "=== VERIFYING /VAR MOUNT ==="
        findmnt --kernel /var
        
        echo "=== CLEANUP TEMP FILES ==="
        rm -f /tmp/var_partition.info
        
        echo ""
        echo "NOTE: For complete application, a system reboot is recommended."
        echo "The remediation procedure specifies: 'Reboot the system or remount all filesystems'"
        echo "mount -a has been executed. To reboot, run: shutdown -r now"
      args:
        executable: /bin/bash
      register: result_7
      ignore_errors: true
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED' and status_5 | trim == 'APPLIED' and status_6 | trim == 'APPLIED'"

    - name: Store requirement 7 details
      set_fact:
        task_7_name: "Reboot system or remount all filesystems"
        task_7_cmd: "mount -a (reboot option mentioned)"
        task_7_rc: "{{ result_7.rc | default(-1) }}"
        data_7: "{{ result_7.stdout | default('') | trim }}"
        status_7: "{{ ('APPLIED' if result_7.rc | default(-1) == 0 else 'FAILED') | trim }}"
        rationale_7: "{{ ('APPLIED: Filesystems remounted, /var now on separate partition. Reboot recommended for complete application.' if result_7.rc | default(-1) == 0 else 'FAILED: Could not remount filesystems') | trim }}"
      when: "status_0 | trim == 'FAILED' and is_new_installation == 'false' and status_1 | trim == 'APPLIED' and status_3 | trim == 'APPLIED' and status_4 | trim == 'APPLIED' and status_5 | trim == 'APPLIED' and status_6 | trim == 'APPLIED'"

    # Requirement 8: Verify /var is on separate partition
    - name: "Req 8 - Verify /var is on separate partition"
      shell: |
        findmnt --kernel /var
      args:
        executable: /bin/bash
      register: result_8
      ignore_errors: true
      changed_when: false

    - name: Store requirement 8 details
      set_fact:
        task_8_name: "Verify /var is on separate partition"
        task_8_cmd: "findmnt --kernel /var"
        task_8_rc: "{{ result_8.rc | default(-1) }}"
        data_8: "{{ result_8.stdout | default('') | trim }}"
        status_8: >-
          {% set output = result_8.stdout | default('') | trim %}
          {% if output != '' and ' / ' not in output %}
            APPLIED
          {% else %}
            FAILED
          {% endif %}
        rationale_8: >-
          {% set output = result_8.stdout | default('') | trim %}
          {% if output != '' and ' / ' not in output %}
            APPLIED: /var is now on separate partition
          {% else %}
            FAILED: /var is still not on separate partition
          {% endif %}

    # Determine overall remediation status
    - name: Determine overall remediation status
      set_fact:
        overall_status: >-
          {% if status_0 | trim == 'APPLIED' %}
            APPLIED
          {% elif status_8 | trim == 'APPLIED' %}
            APPLIED
          {% elif is_new_installation == 'true' and status_2 | trim == 'SKIPPED' %}
            SKIPPED
          {% elif status_0 | trim == 'FAILED' and (status_3 | trim == 'APPLIED' or status_4 | trim == 'APPLIED' or status_5 | trim == 'APPLIED' or status_6 | trim == 'APPLIED' or status_7 | trim == 'APPLIED') %}
            PARTIALLY APPLIED
          {% else %}
            FAILED
          {% endif %}
        overall_details: >-
          {% if status_0 | trim == 'APPLIED' %}
            /var was already on separate partition - no changes needed
          {% elif status_8 | trim == 'APPLIED' %}
            Successfully created separate partition for /var and updated system configuration
          {% elif is_new_installation == 'true' and status_2 | trim == 'SKIPPED' %}
            New installation detected - custom partition setup required during OS installation
          {% elif overall_status | trim == 'PARTIALLY APPLIED' %}
            Some remediation steps were applied but verification failed
          {% else %}
            Remediation failed - /var is not on separate partition
          {% endif %}

    # Final report
    - name: Generate remediation report
      debug:
        msg:
          - "========================================================"
          - "        REMEDIATION REPORT - CIS 1.1.2.4.1"
          - "========================================================"
          - "Reference: {{ kcs_article }}"
          - "========================================================"
          - ""
          - "REQUIREMENT 0 - {{ req_0 }}:"
          - "  Task: {{ task_0_name | default('Task not recorded') }}"
          - "  Command: {{ task_0_cmd | default('N/A') }}"
          - "  Exit code: {{ task_0_rc | default(-1) }}"
          - "  Data: {{ data_0 | default('') | trim }}"
          - "  Status: {{ status_0 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_0 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 1 - {{ req_1 }}:"
          - "  Task: {{ task_1_name | default('Task not recorded') }}"
          - "  Command: {{ task_1_cmd | default('N/A') }}"
          - "  Exit code: {{ task_1_rc | default(-1) }}"
          - "  Data: {{ data_1 | default('') | trim }}"
          - "  Status: {{ status_1 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_1 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 2 - {{ req_2 }}:"
          - "  Task: {{ task_2_name | default('Task not recorded') }}"
          - "  Command: {{ task_2_cmd | default('N/A') }}"
          - "  Exit code: {{ task_2_rc | default(-1) }}"
          - "  Data: {{ data_2 | default('') | trim }}"
          - "  Status: {{ status_2 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_2 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 3 - {{ req_3 }}:"
          - "  Task: {{ task_3_name | default('Task not recorded') }}"
          - "  Command: {{ task_3_cmd | default('N/A') }}"
          - "  Exit code: {{ task_3_rc | default(-1) }}"
          - "  Data: {{ data_3 | default('') | trim }}"
          - "  Status: {{ status_3 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_3 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 4 - {{ req_4 }}:"
          - "  Task: {{ task_4_name | default('Task not recorded') }}"
          - "  Command: {{ task_4_cmd | default('N/A') }}"
          - "  Exit code: {{ task_4_rc | default(-1) }}"
          - "  Data: {{ data_4 | default('') | trim }}"
          - "  Status: {{ status_4 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_4 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 5 - {{ req_5 }}:"
          - "  Task: {{ task_5_name | default('Task not recorded') }}"
          - "  Command: {{ task_5_cmd | default('N/A') }}"
          - "  Exit code: {{ task_5_rc | default(-1) }}"
          - "  Data: {{ data_5 | default('') | trim }}"
          - "  Status: {{ status_5 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_5 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 6 - {{ req_6 }}:"
          - "  Task: {{ task_6_name | default('Task not recorded') }}"
          - "  Command: {{ task_6_cmd | default('N/A') }}"
          - "  Exit code: {{ task_6_rc | default(-1) }}"
          - "  Data: {{ data_6 | default('') | trim }}"
          - "  Status: {{ status_6 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_6 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 7 - {{ req_7 }}:"
          - "  Task: {{ task_7_name | default('Task not recorded') }}"
          - "  Command: {{ task_7_cmd | default('N/A') }}"
          - "  Exit code: {{ task_7_rc | default(-1) }}"
          - "  Data: {{ data_7 | default('') | trim }}"
          - "  Status: {{ status_7 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_7 | default('Not evaluated') | trim }}"
          - ""
          - "REQUIREMENT 8 - {{ req_8 }}:"
          - "  Task: {{ task_8_name | default('Task not recorded') }}"
          - "  Command: {{ task_8_cmd | default('N/A') }}"
          - "  Exit code: {{ task_8_rc | default(-1) }}"
          - "  Data: {{ data_8 | default('') | trim }}"
          - "  Status: {{ status_8 | default('UNKNOWN') | trim }}"
          - "  Details: {{ rationale_8 | default('Not evaluated') | trim }}"
          - ""
          - "========================================================"
          - "OVERALL REMEDIATION:"
          - "  Result: {{ overall_status | default('UNKNOWN') | trim }}"
          - "  Details: {{ overall_details | default('Not evaluated') | trim }}"
          - "========================================================"