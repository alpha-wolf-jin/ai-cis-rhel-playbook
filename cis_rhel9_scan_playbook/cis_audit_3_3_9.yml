---
- name: Data Collection for CIS 3.3.9
  hosts: all
  become: yes
  gather_facts: yes
  vars:
    cis_reference: "CIS RHEL 9 Benchmark v2.0.0 checkpoint 3.3.9"
    req_1: "Check if IPv6 is disabled by examining /sys/module/ipv6/parameters/disable and sysctl net.ipv6.conf.all.disable_ipv6 and net.ipv6.conf.default.disable_ipv6 using the function f_ipv6_chk. Rationale: PASS when IPv6 is determined to be disabled (l_ipv6_disabled='yes') or not disabled (l_ipv6_disabled='no') based on the script's logic, FAIL if the check cannot be performed."
    req_2: "Verify net.ipv4.conf.all.log_martians in the running configuration using command: `sysctl net.ipv4.conf.all.log_martians`. Rationale: PASS when the extracted value is '1', FAIL otherwise."
    req_3: "Verify net.ipv4.conf.default.log_martians in the running configuration using command: `sysctl net.ipv4.conf.default.log_martians`. Rationale: PASS when the extracted value is '1', FAIL otherwise."
    req_4: |
      Check for durable settings of net.ipv4.conf.all.log_martians in configuration files using command: `/usr/lib/systemd/systemd-sysctl --cat-config | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)'` and also check UFW configuration file if applicable. Rationale: PASS when the parameter is found set to '1' in at least one applicable configuration file, FAIL when the parameter is not found in any file or is set to a value other than '1'.
    req_5: |
      Check for durable settings of net.ipv4.conf.default.log_martians in configuration files using command: `/usr/lib/systemd/systemd-sysctl --cat-config | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)'` and also check UFW configuration file if applicable. Rationale: PASS when the parameter is found set to '1' in at least one applicable configuration file, FAIL when the parameter is not found in any file or is set to a value other than '1'.
    req_6: "Run the CIS audit script. Rationale: PASS when the script's final output contains '** PASS **' and l_output2 is empty, FAIL when the output contains '** FAIL **' and l_output2 is not empty."
    req_7: "OVERALL Verify: Ensure suspicious packets are logged. Rationale: PASS when req_2=PASS AND req_3=PASS AND req_4=PASS AND req_5=PASS, FAIL otherwise."

  tasks:
    - name: Initialize data variables
      set_fact:
        task_1_name: "Not executed"
        task_1_cmd: "N/A"
        task_1_rc: -1
        task_2_name: "Not executed"
        task_2_cmd: "N/A"
        task_2_rc: -1
        task_3_name: "Not executed"
        task_3_cmd: "N/A"
        task_3_rc: -1
        task_4_name: "Not executed"
        task_4_cmd: "N/A"
        task_4_rc: -1
        task_5_name: "Not executed"
        task_5_cmd: "N/A"
        task_5_rc: -1
        task_6_name: "Not executed"
        task_6_cmd: "N/A"
        task_6_rc: -1
        task_7_name: "Not executed"
        task_7_cmd: "N/A"
        task_7_rc: -1

    # Requirement 1 - IPv6 check
    - name: Req 1 - Check if IPv6 is disabled
      shell: !unsafe |
        l_ipv6_disabled=""
        ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable && l_ipv6_disabled="yes"
        if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
           sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
           l_ipv6_disabled="yes"
        fi
        [ -z "$l_ipv6_disabled" ] && l_ipv6_disabled="no"
        echo "$l_ipv6_disabled"
      args:
        executable: /bin/bash
      register: result_1
      ignore_errors: true
      changed_when: false

    - name: Store requirement 1 details
      set_fact:
        task_1_name: "Check IPv6 status"
        task_1_cmd: "Check /sys/module/ipv6/parameters/disable and sysctl disable_ipv6 values"
        task_1_rc: "{{ result_1.rc | default(-1) }}"
        data_1: "{{ result_1.stdout | default('') | trim }}"
        status_1: "{{ ('PASS' if (result_1.stdout | default('') | trim == 'yes' or result_1.stdout | default('') | trim == 'no') else 'FAIL') | trim }}"
        rationale_1: "PASS when IPv6 is determined to be disabled (l_ipv6_disabled='yes') or not disabled (l_ipv6_disabled='no') based on the script's logic, FAIL if the check cannot be performed."

    # Requirement 2 - net.ipv4.conf.all.log_martians running config
    - name: Req 2 - Check net.ipv4.conf.all.log_martians running config
      shell: sysctl net.ipv4.conf.all.log_martians
      args:
        executable: /bin/bash
      register: result_2
      ignore_errors: true
      changed_when: false
      when: data_1 | length > 0

    - name: Store requirement 2 details
      set_fact:
        task_2_name: "Check net.ipv4.conf.all.log_martians running config"
        task_2_cmd: "sysctl net.ipv4.conf.all.log_martians"
        task_2_rc: "{{ result_2.rc | default(-1) }}"
        data_2: "{{ result_2.stdout | default('') | trim }}"
        status_2: |
          {{ ('PASS' if (result_2.stdout | default('') | regex_search('net\\.ipv4\\.conf\\.all\\.log_martians\\h*=\\h*1')) else 'FAIL') | trim }}
        rationale_2: "PASS when the extracted value is '1', FAIL otherwise."

    # Requirement 3 - net.ipv4.conf.default.log_martians running config
    - name: Req 3 - Check net.ipv4.conf.default.log_martians running config
      shell: sysctl net.ipv4.conf.default.log_martians
      args:
        executable: /bin/bash
      register: result_3
      ignore_errors: true
      changed_when: false
      when: data_1 | length > 0

    - name: Store requirement 3 details
      set_fact:
        task_3_name: "Check net.ipv4.conf.default.log_martians running config"
        task_3_cmd: "sysctl net.ipv4.conf.default.log_martians"
        task_3_rc: "{{ result_3.rc | default(-1) }}"
        data_3: "{{ result_3.stdout | default('') | trim }}"
        status_3: |
          {{ ('PASS' if (result_3.stdout | default('') | regex_search('net\\.ipv4\\.conf\\.default\\.log_martians\\h*=\\h*1')) else 'FAIL') | trim }}
        rationale_3: "PASS when the extracted value is '1', FAIL otherwise."

    # Requirement 4 - net.ipv4.conf.all.log_martians durable settings (using exact audit procedure logic)
    - name: Req 4 - Check net.ipv4.conf.all.log_martians durable settings
      shell: !unsafe |
        l_kpname="net.ipv4.conf.all.log_martians"
        l_kpvalue="1"
        l_ufwscf="$([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)"
        
        unset A_out; declare -A A_out # Check durable setting (files)
        while read -r l_out; do
          if [ -n "$l_out" ]; then
            if [[ $l_out =~ ^\s*# ]]; then
              l_file="${l_out//# /}"
            else
              l_kpar="$(awk -F= '{print $1}' <<< "$l_out" | xargs)"
              [ "$l_kpar" = "$l_kpname" ] && A_out+=(["$l_kpar"]="$l_file")
            fi
          fi
        done < <(/usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)')
        
        if [ -n "$l_ufwscf" ]; then # Account for systems with UFW (Not covered by systemd-sysctl --cat-config)
          l_kpar="$(grep -Po "^\h*$l_kpname\b" "$l_ufwscf" 2>/dev/null | xargs)"
          l_kpar="${l_kpar//\//.}"
          [ "$l_kpar" = "$l_kpname" ] && A_out+=(["$l_kpar"]="$l_ufwscf")
        fi
        
        if (( ${#A_out[@]} > 0 )); then # Assess output from files and generate output
          found_correct=0
          found_incorrect=0
          while IFS="=" read -r l_fkpname l_fkpvalue; do
            l_fkpname="${l_fkpname// /}"; l_fkpvalue="${l_fkpvalue// /}"
            if [ "$l_fkpvalue" = "$l_kpvalue" ]; then
              found_correct=1
            else
              found_incorrect=1
            fi
          done < <(grep -Po "^\h*$l_kpname\h*=\h*\S+" "${!A_out[@]}" 2>/dev/null)
          
          if [ $found_correct -eq 1 ]; then
            echo "PASS: Parameter found set to 1 in configuration file(s)"
          else
            echo "FAIL: Parameter found but not set to 1 in configuration file(s)"
          fi
        else
          echo "FAIL: Parameter not found in any kernel parameter configuration file"
        fi
      args:
        executable: /bin/bash
      register: result_4
      ignore_errors: true
      changed_when: false
      when: data_1 | length > 0

    - name: Store requirement 4 details
      set_fact:
        task_4_name: "Check net.ipv4.conf.all.log_martians durable settings"
        task_4_cmd: "Check systemd-sysctl --cat-config and UFW config using audit procedure logic"
        task_4_rc: "{{ result_4.rc | default(-1) }}"
        data_4: "{{ result_4.stdout | default('') | trim }}"
        status_4: "{{ ('PASS' if (result_4.stdout | default('') | regex_search('PASS:')) else 'FAIL') | trim }}"
        rationale_4: "PASS when the parameter is found set to '1' in at least one applicable configuration file, FAIL when the parameter is not found in any file or is set to a value other than '1'."

    # Requirement 5 - net.ipv4.conf.default.log_martians durable settings (using exact audit procedure logic)
    - name: Req 5 - Check net.ipv4.conf.default.log_martians durable settings
      shell: !unsafe |
        l_kpname="net.ipv4.conf.default.log_martians"
        l_kpvalue="1"
        l_ufwscf="$([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)"
        
        unset A_out; declare -A A_out # Check durable setting (files)
        while read -r l_out; do
          if [ -n "$l_out" ]; then
            if [[ $l_out =~ ^\s*# ]]; then
              l_file="${l_out//# /}"
            else
              l_kpar="$(awk -F= '{print $1}' <<< "$l_out" | xargs)"
              [ "$l_kpar" = "$l_kpname" ] && A_out+=(["$l_kpar"]="$l_file")
            fi
          fi
        done < <(/usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)')
        
        if [ -n "$l_ufwscf" ]; then # Account for systems with UFW (Not covered by systemd-sysctl --cat-config)
          l_kpar="$(grep -Po "^\h*$l_kpname\b" "$l_ufwscf" 2>/dev/null | xargs)"
          l_kpar="${l_kpar//\//.}"
          [ "$l_kpar" = "$l_kpname" ] && A_out+=(["$l_kpar"]="$l_ufwscf")
        fi
        
        if (( ${#A_out[@]} > 0 )); then # Assess output from files and generate output
          found_correct=0
          found_incorrect=0
          while IFS="=" read -r l_fkpname l_fkpvalue; do
            l_fkpname="${l_fkpname// /}"; l_fkpvalue="${l_fkpvalue// /}"
            if [ "$l_fkpvalue" = "$l_kpvalue" ]; then
              found_correct=1
            else
              found_incorrect=1
            fi
          done < <(grep -Po "^\h*$l_kpname\h*=\h*\S+" "${!A_out[@]}" 2>/dev/null)
          
          if [ $found_correct -eq 1 ]; then
            echo "PASS: Parameter found set to 1 in configuration file(s)"
          else
            echo "FAIL: Parameter found but not set to 1 in configuration file(s)"
          fi
        else
          echo "FAIL: Parameter not found in any kernel parameter configuration file"
        fi
      args:
        executable: /bin/bash
      register: result_5
      ignore_errors: true
      changed_when: false
      when: data_1 | length > 0

    - name: Store requirement 5 details
      set_fact:
        task_5_name: "Check net.ipv4.conf.default.log_martians durable settings"
        task_5_cmd: "Check systemd-sysctl --cat-config and UFW config using audit procedure logic"
        task_5_rc: "{{ result_5.rc | default(-1) }}"
        data_5: "{{ result_5.stdout | default('') | trim }}"
        status_5: "{{ ('PASS' if (result_5.stdout | default('') | regex_search('PASS:')) else 'FAIL') | trim }}"
        rationale_5: "PASS when the parameter is found set to '1' in at least one applicable configuration file, FAIL when the parameter is not found in any file or is set to a value other than '1'."

    # Requirement 6 - Execute CIS audit script (complete script)
    - name: Req 6 - Create CIS audit script
      copy:
        dest: "/tmp/cis_audit_3.3.9.sh"
        mode: '0700'
        content: |
          {% raw %}
          #!/usr/bin/env bash
          {
             l_output="" l_output2="" l_ipv6_disabled="" # Clear output variables
             a_parlist=("net.ipv4.conf.all.log_martians=1" "net.ipv4.conf.default.log_martians=1")
             l_ufwscf="$([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)"
             
             f_ipv6_chk()
             {
                l_ipv6_disabled=""
                ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable && l_ipv6_disabled="yes"
                if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
                   sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
                   l_ipv6_disabled="yes"
                fi
                [ -z "$l_ipv6_disabled" ] && l_ipv6_disabled="no"
             }
             
             f_kernel_parameter_chk()
             {
                l_krp="$(sysctl "$l_kpname" | awk